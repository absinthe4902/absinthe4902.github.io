# Chapter 3 람다 표현식

> 람다를 쓰는 이유? 
익명 클래스로 다양한 동작을 구현할 수 있지만 만족할 만큼 코드가 깔끔하지 않아서.

아무튼 중요한 사실은 익명클래스도 람다도 코드를 인수로 전달 할 수 있는 귀중한 기능이다. 더 정확하게는 람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화한 것이라고 할 수 있다. 람다 표현식에는 이름이 없지만, 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트는 가질 수 있다. 

익명: 이름이 없어서 익명이다. 메서드를 안 만드니 작명 걱정도 안하고 구현할 코드에 대해 걱정이 줄어든다. 

함수: 람다는 메서드처럼 특정 클래스에 종속이 안되어서 그냥 함수라고 부른다. 

전달: 람다는 코드를 인수로 전달하는 귀중안 기능

간결성: 익명 클래스보다 훨씬 보기 쉽고 깔끔, 자질구레한 것이 많이 줄었다. 

![https://1.bp.blogspot.com/-J2_b1ChO_rA/U6XhoM86irI/AAAAAAAADFw/BjxLjcZGo4o/s1600/lambdaExpressionExample.jpg](https://1.bp.blogspot.com/-J2_b1ChO_rA/U6XhoM86irI/AAAAAAAADFw/BjxLjcZGo4o/s1600/lambdaExpressionExample.jpg)

람다의 구조인데 앞 부분은 파라메터의 리스트, → 모양은 람다의 파라미터 리스트와 바디를 구분하는 용도이고, 그 뒤가 람다의 바디이다. 람다의 바디를 {}로 쌓기도 하는데 나중가면 저렇게 싼 형태가 더 알아보기 힘들다고 한다...

**람다 표현식에는 return이 함축되어있어서 웬만하면 return을 직접 명시하지 않는다.** 

```java
(param) -> expression 
(param) -> { statements; }

// expression 표현식
b + 1 
// statements 구문
a = b + 1; 
// expression statement 
a++;

// 무슨 차이가 있나 했더니 statement가 최종 값을 넣는 형태로 
// 완성된 형태라서 expression을 포함하고 있다. 
```

## 3.2 어디에, 어떻게 람다를 사용하나?

---

람다를 사용할 수 있는 부분은 함수형 인터페이스를 파라메터로 받는 자리이다. 함수형 인터페이스란 오직 하나의 추상메서드만 가지고 있는 인터페이스이다. 예시의 코드처럼 @FunctionalInterface 어노테이션이 함께 있다. 

람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있으므로 전체 표현식을 함수형 인터페이스의 인스턴스로 취급한다. 따지고보면 함수형 인터페이스를 구현한 클래스의 인스턴스로 취급하는 것이다. 

```java
@FunctionalInterface
public interface Predicate<T> {

    /**
     * Evaluates this predicate on the given argument.
     *
     * @param t the input argument
     * @return {@code true} if the input argument matches the predicate,
     * otherwise {@code false}
     */
    boolean test(T t);
```

람다가 이름도 없이 그냥 띡 던져놓기만 해도 관련 메소드를 착착 만들 수 있었던 이유는.. 함수형 메서드가 가지고 있는 메서드는 하나니까 어련히 저걸 만들어서 던지겠지 하는 것도 있고 람다가 던지는 파라메터 리스트, 반환 값을 맞춰본다. 

## 3.3 람다 활용: 실행 어라운드 패턴

---

자원 처리(데이터 베이스, 파일 등등)에 사용하는 순환 패턴은 자원을 열고, 처리한 다음에 자원을 닫는 순서로 이루어진다. 이걸 실행 어라운드 패턴이라고 한다. 

여기서 어떻게 람다를 활용하나? 어차피 실행부를 감쌓는 자원열고닫기 부분은 동일하다. 실행부에서 뭘 하는지가 중요한데 그 실행부를 동작 파라메터화를 시키고, 실제로 호출을 할 때 내 입맛에 맞게 람다로 만든 표현식을 던지면 일이 간단해진다. 

1. 함수형 인터페이스 만들기 
2. 함수형 인터페이스를 파라메터로 받는 재활용 메서드 만들기 
3. 재활용 메서드 안에서 함수형 인터페이스의 단 하나 뿐인 추상메서드 호출하기 
4. 실제 실행 단에서 재활용 메서드 호출 할 때 원하는 행동 람다로 만들어서 던지기 

```java
@FunctionalInterface
interface FileProcess {
    void work (BufferedReader b);
}

public class ExFile {

    static void processFile(FileProcess p) {

        // try-with-resource 형태라서 따로 자원을 닫을 필요가 없어졌다!
        try (BufferedReader reader = new BufferedReader(new FileReader("C:\\Temp\\file1.txt"))) {
            p.work(reader);
        } catch (Exception e){
            System.out.println(e.getMessage());
        }

    }

    public static void main(String[] args) {
        // 1그냥 파일 읽기
        processFile((BufferedReader r) -> {
            try {
                System.out.println(r.readLine());
            } catch (IOException e) {
                e.printStackTrace();
            }
        });

        // 2 파일 내용 복사하기
        processFile((BufferedReader r ) -> {
            try {
                try (BufferedWriter r2 = new BufferedWriter(new FileWriter("C:\\Temp\\file2.txt"))) {
                    r2.write(r.readLine());
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        });
    }
}
```

책에서 말한 것처럼 실행어라운드는 동일하게 사용하고 자원을 실제로 어떻게 사용할 것인지는 람다로 전달해 내 마음대로 실행을 했다. **try-with-resource 형식을 잘 기억하자. 이걸 그대로 사용하면 매번 따로 자원을 닫아주는 번거로운 일을 하지 않아도 된다. 그냥 자원을 열 때 try () 안에서 연다는 걸 알면 된다.** 

## 3.4 함수형 인터페이스 사용

---

함수형 인터페이스의 추상 메서드는 람다 표현식의 시그니처 (반환값, 파라메터값)을 묘사한다. 함수형 인터페이스의 추상 메서드 시그니처를 함수 디스크립터라고 한다. 

앞에서도 말한 것처럼 람다는 함수형 인터페이스에서 사용이 가능한데 자바는 이미 다양한 형태의 함수 인터페이스를 상황별로 만들어놨고 우리는 필요에 따라서 반환값과 파라메터값을 고려해서 쓰기만 하면 된다. (Comparable, Runnable, Callable 등등) 

![https://javaconceptoftheday.com/wp-content/uploads/2019/03/Java8FunctionalInterfaces.png](https://javaconceptoftheday.com/wp-content/uploads/2019/03/Java8FunctionalInterfaces.png)

대략적인 쓰이는 상황들 

Predicate: 객체를 사용해서 boolean 값 return, 한마디로 true/false 값 나누고 싶을 때 사용 (test)

```java
public class ExPredicate {

    // 맨 앞 <T> 왜 있나 했는데 filter 에서 쓰이는 T를 정의해주는 느낌이다
    public static <T> List<T> filter(List<T> list, Predicate<T> p) {
        List<T> results = new ArrayList<>();
        for(T t: list) {
            if(p.test(t)) {
                results.add(t);
            }
        }

        return results;
    }

    // 람다의 준비물
    // 1.functional method
    // 2.recycle method
    // 3.call recycle method with lambda
    public static void main(String[] args) {

        List<String> sample = Arrays.asList("longlong", "short", "");
        List<String> notShort = filter(sample, (String s) -> s.length() > 3);
        System.out.println(notShort);

        IntPredicate same = (int i) -> i == 1000;
        Predicate<Integer> sameBoxing = (Integer i)-> i == (new Integer(1000));

        System.out.println(same.test(1000));
        System.out.println(sameBoxing.test(1000));

    }

    List<Apple> filterApples(List<Apple> apples, Color color, int weight, boolean flag) {
        List<Apple> result = new ArrayList<>();
        for(Apple apple : apples) {
            if((flag && apple.getColor().equals(color)) ||
                    (!flag && apple.getWeight() > weight)) {
                        result.add(apple);
            }
        }

        return result;
    }
}
```

Consumer: 객체를 인수로 받아서 어떤 행동을 하고 싶을 때 (accept)

```java
public class ExConsumer {

    // Consumer 은 반환값이 없어서 뭔가를 실행하고자 할 때 사용한다
    public static <T> void doSomething(List<T> list, Consumer<T> c) {

        for(T t: list) {
            c.accept(t);
        }
    }

    public static void main(String[] args) {

        List<Integer> test = Arrays.asList(1,2,3);
        doSomething(test, (Integer i) -> System.out.println(i/2));
    }
}
```

Function: 객체를 인수로 받아서 또 다른 타입의 객체를 반환한다, 가장 함수다운 함수 (apply) 

```java
public class ExFunction {

    // Function 은 입력 값도 있고 반환 값도 있는 형식이다.
    static <T, R> Map<T, R> map(List<T> list, Function<T, R> f) {

        Map<T, R> valueMap = new HashMap<>();

        for(T t:list) {
            valueMap.put(t, f.apply(t));
        }

        return valueMap;
    }

    public static void main(String[] args) {
        List<String> test = Arrays.asList("one", "two", "Three");

        Map<String, Integer> testLen = map(test, String::length);
        System.out.println(testLen);
    }
}
```

기본형 특화 (IntPredicate, IntSupplier etc)

기본형 값들을 위의 메소드에 사용하려면 참조형만 값으로 받는 제네릭의 특성 때문에 Integer, Double등으로 박싱을 해야 한다. 최신 자바는 오토박싱을 해주기는 하는데 **박싱은 객체라서 힙에 차곡차곡 쌓이게 된다. 결국 메모리를 더 쓰게 되고,** 기본형을 가져올때도 메모리 탐색을 해야 한다. 

이것이 모이면 결국 자원낭비라서 그냥 기본형으로 함수형인터페이스를 사용한다면 기본형 특화를 쓰는게 좋다. 

> 자바에서 미리 만들어둔 함수형 인터페이스 말고도 우리가 원하는 함수형 인터페이스는 언제든 만들 수 있다.